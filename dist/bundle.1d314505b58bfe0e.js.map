{"version":3,"file":"bundle.1d314505b58bfe0e.js","mappings":";;;;;AAAAA,MAAM,CAACC,iBAAP,CAAyB,eAAzB,EAA0C;EAExCC,IAAI,EAAE,YAAW;IACb,MAAMC,cAAc,GAAGC,QAAQ,CAACC,aAAT,CAAuB,kBAAvB,CAAvB;IACA,MAAMC,OAAO,GAAGF,QAAQ,CAACC,aAAT,CAAuB,iBAAvB,CAAhB;IACA,MAAME,KAAK,GAAGH,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAd;IAEAG,OAAO,CAACC,gBAAR,CAAyB,aAAzB,EAAyCC,CAAD,IAAO;MAC7CC,OAAO,CAACC,GAAR,CAAY,cAAZ;MACEC,eAAe,GAAG,IAAlB;IACH,CAHD;IAKAL,OAAO,CAACC,gBAAR,CAAyB,YAAzB,EAAwCC,CAAD,IAAO;MAC1CG,eAAe,GAAG,KAAlB;IACH,CAFD;IAIAL,OAAO,CAACC,gBAAR,CAAyB,eAAzB,EAA0CK,cAA1C;IACAN,OAAO,CAACC,gBAAR,CAAyB,eAAzB,EAA0CM,WAA1C,EAfa,CAiBb;;IACAZ,cAAc,CAACM,gBAAf,CAAgC,OAAhC,EAAyC,UAASO,EAAT,EAAaC,MAAb,EAAoB;MACzD,MAAMC,kBAAkB,GAAGF,EAAE,IAAIA,EAAE,CAACG,MAAT,IAAmBH,EAAE,CAACG,MAAH,CAAUC,aAAxD;;MACA,IAAId,OAAO,IAAIY,kBAAkB,KAAKZ,OAAtC,EAA+C;QAC3C,MAAMe,KAAK,GAAGf,OAAO,CAACgB,YAAR,CAAqB,OAArB,CAAd;QACAC,MAAM,CAACC,IAAP,CAAYH,KAAZ,EAAmBI,OAAnB,CAA4BC,GAAD,IAASL,KAAK,CAACK,GAAD,CAAL,GAAaL,KAAK,CAACK,GAAD,CAAL,GAAa,CAA9D;QACApB,OAAO,CAACqB,YAAR,CAAqB,OAArB,EAA8BN,KAA9B;MACH;IACJ,CAPD;;IASA,SAASP,cAAT,CAAwBc,KAAxB,EAA+B;MAC7B,IAAIf,eAAJ,EAAqB;QACnBgB,EAAE,CAACC,QAAH,CAAYC,QAAZ,CAAqBC,CAArB,IACEJ,KAAK,CAACT,MAAN,CAAac,cAAb,CAA4BC,CAA5B,GAAgCC,cADlC;QAGAN,EAAE,CAACC,QAAH,CAAYC,QAAZ,CAAqBG,CAArB,IACEN,KAAK,CAACT,MAAN,CAAac,cAAb,CAA4BD,CAA5B,GAAgCG,cADlC;MAED;IACF;;IAED,SAASpB,WAAT,CAAqBa,KAArB,EAA4B;MAC1B,IAAIf,eAAJ,EAAqB;QACnB,KAAKuB,WAAL,IACE,IAAIR,KAAK,CAACT,MAAN,CAAakB,YAAb,GAA4BT,KAAK,CAACT,MAAN,CAAamB,WAD/C;QAGA,KAAKF,WAAL,GAAmBG,IAAI,CAACC,GAAL,CACjBD,IAAI,CAACE,GAAL,CAAS,KAAKL,WAAd,EAA2B,KAAKM,IAAL,CAAUC,QAArC,CADiB,EAEjB,KAAKD,IAAL,CAAUE,QAFO,CAAnB;QAKAf,EAAE,CAACC,QAAH,CAAYT,KAAZ,CAAkBa,CAAlB,GAAsBE,WAAW,GAAGS,YAAY,CAACX,CAAjD;QACAL,EAAE,CAACC,QAAH,CAAYT,KAAZ,CAAkBW,CAAlB,GAAsBI,WAAW,GAAGS,YAAY,CAACb,CAAjD;QACAH,EAAE,CAACC,QAAH,CAAYT,KAAZ,CAAkByB,CAAlB,GAAsBV,WAAW,GAAGS,YAAY,CAACC,CAAjD;MACD;IACF;EAEN;AAvDyC,CAA1C;AAyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K","sources":["webpack:///./script.js"],"sourcesContent":["AFRAME.registerComponent('markerhandler', {\n\n  init: function() {\n      const animatedMarker = document.querySelector(\"#animated-marker\");\n      const aEntity = document.querySelector(\"#animated-model\");\n      const scene = document.querySelector('#scene');\n\n      sceneEl.addEventListener(\"markerFound\", (e) => {\n        console.log(\"marker found\");\n          isMarkerVisible = true;\n      });\n      \n      sceneEl.addEventListener(\"markerLost\", (e) => {\n          isMarkerVisible = false;\n      });\n\n      sceneEl.addEventListener(\"onefingermove\", handleRotation);\n      sceneEl.addEventListener(\"twofingermove\", handleScale);\n\n      // every click, we make our model grow in size :)\n      animatedMarker.addEventListener('click', function(ev, target){\n          const intersectedElement = ev && ev.detail && ev.detail.intersectedEl;\n          if (aEntity && intersectedElement === aEntity) {\n              const scale = aEntity.getAttribute('scale');\n              Object.keys(scale).forEach((key) => scale[key] = scale[key] + 1);\n              aEntity.setAttribute('scale', scale);\n          }\n      });\n\n      function handleRotation(event) {\n        if (isMarkerVisible) {\n          el.object3D.rotation.y +=\n            event.detail.positionChange.x * rotationFactor;\n    \n          el.object3D.rotation.x +=\n            event.detail.positionChange.y * rotationFactor;\n        }\n      }\n\n      function handleScale(event) {\n        if (isMarkerVisible) {\n          this.scaleFactor *=\n            1 + event.detail.spreadChange / event.detail.startSpread;\n    \n          this.scaleFactor = Math.min(\n            Math.max(this.scaleFactor, this.data.minScale),\n            this.data.maxScale\n          );\n    \n          el.object3D.scale.x = scaleFactor * initialScale.x;\n          el.object3D.scale.y = scaleFactor * initialScale.y;\n          el.object3D.scale.z = scaleFactor * initialScale.z;\n        }\n      }\n      \n}});\n\n/*\nAFRAME.registerComponent(\"gesture-detector\", {\n  schema: {\n    element: { default: \"\" }\n  },\n\n  init: function() {\n    this.targetElement =\n      this.data.element && document.querySelector(this.data.element);\n\n    if (!this.targetElement) {\n      this.targetElement = this.el;\n    }\n\n    this.internalState = {\n      previousState: null\n    };\n\n    this.emitGestureEvent = this.emitGestureEvent.bind(this);\n\n    this.targetElement.addEventListener(\"touchstart\", this.emitGestureEvent);\n\n    this.targetElement.addEventListener(\"touchend\", this.emitGestureEvent);\n\n    this.targetElement.addEventListener(\"touchmove\", this.emitGestureEvent);\n  },\n\n  remove: function() {\n    this.targetElement.removeEventListener(\"touchstart\", this.emitGestureEvent);\n\n    this.targetElement.removeEventListener(\"touchend\", this.emitGestureEvent);\n\n    this.targetElement.removeEventListener(\"touchmove\", this.emitGestureEvent);\n  },\n\n  emitGestureEvent(event) {\n    const currentState = this.getTouchState(event);\n\n    const previousState = this.internalState.previousState;\n\n    const gestureContinues =\n      previousState &&\n      currentState &&\n      currentState.touchCount == previousState.touchCount;\n\n    const gestureEnded = previousState && !gestureContinues;\n\n    const gestureStarted = currentState && !gestureContinues;\n\n    if (gestureEnded) {\n      const eventName =\n        this.getEventPrefix(previousState.touchCount) + \"fingerend\";\n\n      this.el.emit(eventName, previousState);\n\n      this.internalState.previousState = null;\n    }\n\n    if (gestureStarted) {\n      currentState.startTime = performance.now();\n\n      currentState.startPosition = currentState.position;\n\n      currentState.startSpread = currentState.spread;\n\n      const eventName =\n        this.getEventPrefix(currentState.touchCount) + \"fingerstart\";\n\n      this.el.emit(eventName, currentState);\n\n      this.internalState.previousState = currentState;\n    }\n\n    if (gestureContinues) {\n      const eventDetail = {\n        positionChange: {\n          x: currentState.position.x - previousState.position.x,\n\n          y: currentState.position.y - previousState.position.y\n        }\n      };\n\n      if (currentState.spread) {\n        eventDetail.spreadChange = currentState.spread - previousState.spread;\n      }\n\n      // Update state with new data\n\n      Object.assign(previousState, currentState);\n\n      // Add state data to event detail\n\n      Object.assign(eventDetail, previousState);\n\n      const eventName =\n        this.getEventPrefix(currentState.touchCount) + \"fingermove\";\n\n      this.el.emit(eventName, eventDetail);\n    }\n  },\n\n  getTouchState: function(event) {\n    if (event.touches.length === 0) {\n      return null;\n    }\n\n    // Convert event.touches to an array so we can use reduce\n\n    const touchList = [];\n\n    for (let i = 0; i < event.touches.length; i++) {\n      touchList.push(event.touches[i]);\n    }\n\n    const touchState = {\n      touchCount: touchList.length\n    };\n\n    // Calculate center of all current touches\n\n    const centerPositionRawX =\n      touchList.reduce((sum, touch) => sum + touch.clientX, 0) /\n      touchList.length;\n\n    const centerPositionRawY =\n      touchList.reduce((sum, touch) => sum + touch.clientY, 0) /\n      touchList.length;\n\n    touchState.positionRaw = { x: centerPositionRawX, y: centerPositionRawY };\n\n    // Scale touch position and spread by average of window dimensions\n\n    const screenScale = 2 / (window.innerWidth + window.innerHeight);\n\n    touchState.position = {\n      x: centerPositionRawX * screenScale,\n      y: centerPositionRawY * screenScale\n    };\n\n    // Calculate average spread of touches from the center point\n\n    if (touchList.length >= 2) {\n      const spread =\n        touchList.reduce((sum, touch) => {\n          return (\n            sum +\n            Math.sqrt(\n              Math.pow(centerPositionRawX - touch.clientX, 2) +\n                Math.pow(centerPositionRawY - touch.clientY, 2)\n            )\n          );\n        }, 0) / touchList.length;\n\n      touchState.spread = spread * screenScale;\n    }\n\n    return touchState;\n  },\n\n  getEventPrefix(touchCount) {\n    const numberNames = [\"one\", \"two\", \"three\", \"many\"];\n\n    return numberNames[Math.min(touchCount, 4) - 1];\n  }\n});*/"],"names":["AFRAME","registerComponent","init","animatedMarker","document","querySelector","aEntity","scene","sceneEl","addEventListener","e","console","log","isMarkerVisible","handleRotation","handleScale","ev","target","intersectedElement","detail","intersectedEl","scale","getAttribute","Object","keys","forEach","key","setAttribute","event","el","object3D","rotation","y","positionChange","x","rotationFactor","scaleFactor","spreadChange","startSpread","Math","min","max","data","minScale","maxScale","initialScale","z"],"sourceRoot":""}